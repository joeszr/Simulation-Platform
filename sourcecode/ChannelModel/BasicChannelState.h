/// COPRIGHT NOTICE
/// Copyright (c) 2010,
/// All right reserved.
///
///@file BasicChannelState.h
///@brief  BasicChannelState类声明
///
///包括构造函数，析构函数，初始化Map，初始化BasicChannelState，确定是否LOS和SCM/ITU模型下计算扩展参数的函数声明
///
///@author wangfei
#pragma once
#include "classholder.h"
#include "libfiles.h"
#include "../SafeUnordered_map.h"
#include "../Utility/Random.h"

namespace cm {
    class Point;
    class Tx;
    class Rx;
    class GaussianMap;
    class AntennaPanel;

    typedef std::pair<double, double> POS;
    typedef std::pair<POS, POS> KEY;

    //bool operator==(const POS& pos1,const POS& pos2);
    //bool operator==(const KEY& key1,const KEY key2);
    size_t POSHash(const POS& pos);
    size_t KEYHash(const KEY& key);


    /// 记录基本信道信息的类
    class BasicChannelState {
    private:
        /// 用来产生可视径时延扩展相关性的随机分布地图
        static std::shared_ptr<GaussianMap> m_pDSMapLOS;
        /// 用来产生可视径离开角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAODMapLOS;
        /// 用来产生可视径到达角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAOAMapLOS;
        /// 用来产生可视径垂直离开角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pEODMapLOS;
        /// 用来产生可视径垂直到达角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pEOAMapLOS;
        /// 用来产生可视径阴影衰落的随机分布地图
        static std::shared_ptr<GaussianMap> m_pSFMapLOS;
        /// 用来产生可视径K值（LOS径功率分配相关）的随机分布地图
        static std::shared_ptr<GaussianMap> m_pKMapLOS;
        /// 用来产生非可视径时延扩展相关性的随机分布地图
        static std::shared_ptr<GaussianMap> m_pDSMapNLOS;
        /// 用来产生非可视径离开角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAODMapNLOS;
        /// 用来产生非可视径到达角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAOAMapNLOS;
        /// 用来产生非可视径垂直离开角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pEODMapNLOS;
        /// 用来产生非可视径垂直到达角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pEOAMapNLOS;
        /// 用来产生非可视径阴影衰落的随机分布地图
        static std::shared_ptr<GaussianMap> m_pSFMapNLOS;
        /// 用来产生室外到室内时延扩展相关性的随机分布地图
        static std::shared_ptr<GaussianMap> m_pDSMapO2I;
        /// 用来产生室外到室内离开角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAODMapO2I;
        /// 用来产生室外到室内到达角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAOAMapO2I;
        /// 用来产生室外到室内垂直离开角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pEODMapO2I;
        /// 用来产生室外到室内垂直到达角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pEOAMapO2I;
        /// 用来产生室外到室内阴影衰落的随机分布地图
        static std::shared_ptr<GaussianMap> m_pSFMapO2I;
         /// 用来产生可视径时延扩展相关性的随机分布地图
        static std::shared_ptr<GaussianMap> m_pDSMapPicoToUELOS;
        /// 用来产生可视径离开角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAODMapPicoToUELOS;
        /// 用来产生可视径到达角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAOAMapPicoToUELOS;
        /// 用来产生可视径阴影衰落的随机分布地图
        static std::shared_ptr<GaussianMap> m_pSFMapPicoToUELOS;
        /// 用来产生可视径K值（LOS径功率分配相关）的随机分布地图
        static std::shared_ptr<GaussianMap> m_pKMapPicoToUELOS;
        /// 用来产生非可视径时延扩展相关性的随机分布地图
        static std::shared_ptr<GaussianMap> m_pDSMapPicoToUENLOS;
        /// 用来产生非可视径离开角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAODMapPicoToUENLOS;
        /// 用来产生非可视径到达角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAOAMapPicoToUENLOS;
        /// 用来产生非可视径阴影衰落的随机分布地图
        static std::shared_ptr<GaussianMap> m_pSFMapPicoToUENLOS;
        /// 用来产生室外到室内时延扩展相关性的随机分布地图
        static std::shared_ptr<GaussianMap> m_pDSMapPicoToUEO2I;
        /// 用来产生室外到室内离开角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAODMapPicoToUEO2I;
        /// 用来产生室外到室内到达角角度扩展的随机分布地图
        static std::shared_ptr<GaussianMap> m_pAOAMapPicoToUEO2I;
        /// 用来产生室外到室内阴影衰落的随机分布地图
        static std::shared_ptr<GaussianMap> m_pSFMapPicoToUEO2I;
        /// 用来记录LOS或NLOS的标记量
        static SafeUnordered_map<KEY, bool> m_LOSORNLOS;

    public:
        ///设置该链路类别标识为1---BS2RIS(rx)
        void SetLinkCategory_as_BS2RIS();
        ///设置该链路类别标识为2---RIS(tx)2MS
        void SetLinkCategory_as_RIS2MS();
        /// @brief 初始化地图变量
        static void InitializeMap();

    public:
        std::pair<int,int> RIS_BtsBeamIndex;
        //临时域，可优化
        std::pair<int,int> RIS_BtsBeamIndex2;
        /// 标记是否为可视径
        bool m_bIsLOS;
        /// 记录发送者到接收者的俯角，单位：弧度
        double m_dUE2BSTiltRAD;
        /// 发送者到接收者的距离，单位：米
        double m_d2DDistanceM;
        /// 发送者到接收者的3D距离，单位：米
        double m_d3DDistanceM;
        /// pure path loss path loss in dB, generated by the Hata Model, no include antenna pattern, etc
        double m_PurePathLossDB; //****************************************************************
        /// The path loss between UE and NB
        double m_PathLossDB;
        /// 近场pathloss
        std::map<std::pair<int,int>,double> TXRU2LL;
        /// The link loss.
        double m_LoSLinkLossDB;
        ///The BS antenna pattern gain
        double m_dAveTxAntennaPatternDB;
        ///the BS antenna pattern gain 
        double m_dTxAntennaPatternDB;
        /// The UE antenna pattern gain
        double m_dRxAntennaPatternDB;
        std::vector<double> m_vdRxAntennaPatternDB;
        /// The angle between line of sight line and BS antenna orientation
        double m_AODLOSRAD;
        /// The angle between line of sight line and UE antenna orientation
        double m_AOALOSRAD;
        /// The elevation angle between line of sight line and BS antenna orientation
        double m_EODLOSRAD;
        /// The elevation angle between line of sight line and UE antenna orientation
        double m_EOALOSRAD;
        /// The offset of EODLOSRAD
        double m_EODOFFSETRAD;
        //////////////////////////
        double m_EODSpreadAVE_LogDeg;
        double m_EODSpreadSTD_LogDeg;
        double m_EODoffsetAVE;

        /// The shadow fading
        double m_ShadowFadingDB;
        /// delay spread
        double m_DelaySpread; 
        /// angle of departure spread
        double m_AODSpreadDeg; 
        /// angle of arrival spread
        double m_AOASpreadDeg;
        /// elvation angle of departure spread
        double m_EODSpreadDeg;
        /// elvation angle of arrival spread
        double m_EOASpreadDeg;
        /// the K factor
        double m_KFactorDB; //****************************************************************
        double m_dPhaseDegLOSXX;
        double m_dPhaseDegLOSYY;
        /// The point for transmiter
        Tx* m_pTx; //****************************************************************
        /// The point for receiver
        Rx* m_pRx; //****************************************************************
        /// The link loss of diffrent wrapping position.
        std::vector<double> m_vAveLinkLossDB;
        ///
        int m_BCS_StrongestUEPanelIndex;
        /// 用于小尺度的公共参数
        int m_iNumOfPath; //****************************************************************
        double m_delayScaling;
        double m_sigma;
        double m_C_Azimuth;
        double m_C_Elevation;
        int m_iTxAntennaNum;//没用
        double m_dClusterASD;
        double m_dClusterASA;
        double m_dClusterESD;
        double m_dClusterESA;
        ///链路类别标识0---BS2UE,1---BS2RIS(rx),2---RIS(tx)2MS
        int m_iLinkCategory;
        itpp::Mat<std::complex<double> > Alpha_for_CouplingLoss;
        //近场coupling loss
        itpp::Mat<std::complex<double> > Alpha_for_CouplingLoss1;
    public:
        /// Initialize the basic channel m_state.
        void Initialize(Tx& _tx, Rx& _rx);

        bool IsUMAOrRMAOrUMI_Indoor_UE(Rx &_rx);

        /// 判断该链路是否为Macro-UE
        bool IsMacroToUE() const;
        /// 判断该链路是否为Macro-UE
        bool IsPicoToUE() const;
        Tx& GetItsMacro() const;
    private:
        /// 
        bool DecideLOS(double _dDisM, Tx& _tx, Rx& _rx);
        /// initialize some channel model parameters of ITU channel model
        void InitializeSpread(ITU, Point& _tx, Rx& _rx);
        Random random;
    public:
        /// constructor
        BasicChannelState();
        /// destructor
        ~BasicChannelState() = default;
        std::vector<double> m_couplingloss_ris;
        int m_risindex;
    };
}
